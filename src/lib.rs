
extern crate bytes;
extern crate byteorder;

use std::io::{ Read, Result, Write};
use byteorder::{ReadBytesExt};


pub trait UorbMsgMeta {
    const ENCODED_LEN: usize;
    const MSG_HASH_CODE: u16;
    const MSG_RAW_NAME: &'static str;
}

// import code generated by parser at build time
pub mod common {
    use crate::UorbMsgMeta;
    use bytes::{Buf, BufMut, Bytes, IntoBuf};

    include!(concat!(env!("OUT_DIR"), "/common.rs"));
}

/// import all the message definitions
pub use self::common::UorbMessage as UorbMessage;


#[derive(Debug, Clone)]
pub struct UorbHeader {
    pub version: u8,
    /// unique hash of the msg name
    pub hash: u16,
    /// the "instance" of the sensor/entity that sent this
    pub instance_id: u8,
    /// length of the payload in bytes
    pub payload_len: usize,
}



/// Utilities for sending and receiving uORB via a reliable transport

pub const UORB_MAGIC_V1: u8 = 0xAA;

pub fn write_msg<W: Write>(w: &mut W, header: &UorbHeader, data: &UorbMessage) -> Result<()> {
    let payload = data.ser();
//    println!("write payload_len : {}", payload.len());

    let header = &[
        UORB_MAGIC_V1,
        ((header.hash >> 8) & 0xFF) as u8,
        (header.hash & 0xFF) as u8,
        header.instance_id,
        ((payload.len() >> 8) & 0xFF) as u8,
        (payload.len() & 0xFF) as u8,
        ];

    w.write_all(header)?;
    w.write_all(&payload[..])?;

//        Err( Error::new(ErrorKind::Other, " unimplemented"))
    Ok(())
}

/*
// microRTPS uses:
// * [>,>,>,topic_ID,seq,payload_length_H,payload_length_L,CRCHigh,CRCLow,payloadStart, ... ,payloadEnd]

HOWTO transmit/receive uORB
hash the uorb message name to get the hash_val
    magic
    _sendbuf[0] = (hash_val >> 8) & 0xFF;
    _sendbuf[1] = hash_val & 0xFF;
    _sendbuf[2] = instance_id; //the "instance" of the sensor /entity that sent this
    _sendbuf[3] = (payload_len >> 8) & 0xFF;
    _sendbuf[4] = payload_len & 0xFF;
    followed by payload data...
*/

pub fn read_msg<R: Read>(r: &mut R) -> Result<(UorbHeader, UorbMessage)> {

    loop {
        // search for the magic framing value indicating start of the message
        if r.read_u8()? != UORB_MAGIC_V1 {
            continue;
        }

        let hash_h = r.read_u8()?;
        let hash_l = r.read_u8()?;
        let hash_val:u16 = ((hash_h as u16) << 8) + hash_l as u16;
        let instanced_id = r.read_u8()?;
        let payload_len_h = r.read_u8()?;
        let payload_len_l = r.read_u8()?;
        let payload_len:usize = (((payload_len_h as u16) << 8) + payload_len_l  as u16) as usize;

        let header = UorbHeader {
            version: UORB_MAGIC_V1,
            hash: hash_val,
            instance_id: instanced_id,
            payload_len: payload_len,
        };

        //TODO verify that payload size will never exceed this
        let mut payload_buf = [0; 255];
        let payload = &mut payload_buf[..payload_len.into()];
        r.read_exact(payload)?;

        let msg = UorbMessage::parse(header.hash, payload).unwrap();
        return Ok((header, msg));
    }

}






