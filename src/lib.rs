
extern crate bytes;
extern crate byteorder;

use std::io::{ Error, ErrorKind, Read, Result, Write};
use byteorder::{ReadBytesExt};


pub trait UorbMsgMeta {
    const ENCODED_LEN: usize;
    const MSG_HASH_CODE: u16;
    const MSG_RAW_NAME: &'static str;
}

// import code generated by parser at build time
pub mod common {
    use crate::UorbMsgMeta;
    use bytes::{Buf, BufMut, Bytes, IntoBuf};

    include!(concat!(env!("OUT_DIR"), "/common.rs"));
}

/// import all the message definitions
pub use self::common::UorbMessage as UorbMessage;


#[derive(Debug, Clone)]
pub struct UorbHeader {
    /// indicates which version of the header we are sending
    pub version: u8,
    /// unique hash of the msg name
    pub hash: u16,
    /// the "instance" of the sensor/entity that sent this
    pub instance_id: u8,
    /// length of the payload in bytes
    pub payload_len: usize,
}



/// Utilities for sending and receiving uORB via a reliable transport

pub const UORB_MAGIC_V1: u8 = 0xAA;

pub fn write_msg<W: Write>(w: &mut W, header: &UorbHeader, data: &UorbMessage) -> Result<()> {
    let payload = data.ser();

    let header = &[
        header.version,
        ((header.hash >> 8) & 0xFF) as u8,
        (header.hash & 0xFF) as u8,
        header.instance_id,
        ((payload.len() >> 8) & 0xFF) as u8,
        (payload.len() & 0xFF) as u8,
        ];

    w.write_all(header)?;
    w.write_all(&payload[..])?;

    Ok(())
}


pub fn read_msg<R: Read>(r: &mut R) -> Result<(UorbHeader, UorbMessage)> {

    loop {
        // search for the magic framing value indicating start of the message
        if r.read_u8()? != UORB_MAGIC_V1 {
            continue;
        }

        let hash_h = r.read_u8()?;
        let hash_l = r.read_u8()?;
        let hash_val:u16 = ((hash_h as u16) << 8) + hash_l as u16;
        let instanced_id = r.read_u8()?;
        let payload_len_h = r.read_u8()?;
        let payload_len_l = r.read_u8()?;
        let payload_len:usize = (((payload_len_h as u16) << 8) + payload_len_l  as u16) as usize;

        let header = UorbHeader {
            version: UORB_MAGIC_V1,
            hash: hash_val,
            instance_id: instanced_id,
            payload_len: payload_len,
        };

        //TODO verify that payload size will never exceed this
        let mut payload_buf = [0; 255];
        //println!("payload_len: {}", payload_len);
        let payload = &mut payload_buf[..payload_len.into()];
        r.read_exact(payload)?;

        //println!("parse {} len {}", header.hash, payload_len);
        if let Some(msg) = UorbMessage::parse(header.hash, payload) {
            return Ok((header, msg));
        }
        else {
            let err = Error::new(ErrorKind::InvalidInput,
                                     format!("msg hash: {}",  header.hash));
            return Err(err);
        }
    }

}






